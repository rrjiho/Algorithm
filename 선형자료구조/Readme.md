## 선형자료구조

#### 배열과 동적 배열
- 배열은 선언 시 `크기를 지정`해야 하며(고정), 그 이상의 `자료는 넣을 수 없다`는 단점이 존재한다.
- 이를 해결하기 위해 자료 개수가 변함에 따라 크기가 변경되는 배열을 만든다. -> `동적 배열`

#### 동적 배열
- 메모리를 할당 받을 때 배열의 크기가 커질 것을 대비해 `여유 메모리를 미리 할당` 받아 둔다.
- 여유 메모리까지 할당 받은 크기 -> capacity, 실제 원소 수 -> size
- size에 비례해서 (1.5 ~ 2배) capacity 잡음 따라서 append() 연산이 가능하다.
- C# -> `List`

#### 연결 리스트
- 배열 원소의 순서를 유지하면서 삽입, 삭제하는 것은 오랜 시간이 걸린다. -> 연결 리스트로 해결 가능하다.
- 배열은 메모리가 연속적인 위치에 저장되어 있지만 연결 리스트는 원소가 `메모리 여기 저기 흩어져` 있고 `이전, 다음 원소를 가리키는 포인터`를 가지고 있다.
- 그것을 `노드(node)`로 표현하며 맨 처음과 마지막은 `head, tail`을 가진다.
- 새로운 원소를 추가할 때 노드를 연결, 해제만 해주면 되므로 편리하다.
- C# -> `LinkedList`

#### 동적 배열과 연결 리스트 비교 (시간)
- 삽입과 삭제할 일 없거나 배열 끝에서만 할 경우 동적 배열이 대부분 좋은 선택이다.
- 또 빠르게 접근 가능하고 메모리에 연속 배치되어 있으므로 CPU 캐시 효율을 높여준다.
- 만약 모든 원소를 순회하여 삽입, 삭제를 할 경우 연결 리스트가 좋은 선택이다.

#### 스택 & 큐
- 일렬로 늘어 놓은 형태의 자료를 저장하는 방법으로 어느 방향에서 자료를 뺄 수 있는지에 따라 스택과 큐를 구분할 수 있다.
- 스택: LIFO(후입선출 Last In First Out), 상자를 쌓아서 보관하고 빼내는 것을 생각하면 됨 한쪽 끝에서만 자료를 넣고 뺄 수 있다.
- 큐: FIFO(선입선출 First In First Out), 음식점 웨이팅 줄을 생각하면 됨 한쪽 끝에서 자료를 넣고 반대 쪽 끝에서 자료를 뺄 수 있다.
- 동적 배열과 연결 리스트로만 사용하여 표현할 수 있지만 추상화를 위해서 스택과 큐 자료구조를 사용함 -> 의사소통의 편리함 + 기능의 축소화
- C# -> Stack: Push, Pop, Peek / Queue: Enqueue, Dequeue, Peek 사용하여 넣고 빼고 볼 수 있다.
